"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
An index contains one or more pieces of information about a given piece of
source code or software artifact. Complementary information can be merged
together from multiple sources to provide a unified code intelligence
experience.

Programs producing a file of this format is an "indexer" and may operate
somewhere on the spectrum between precision, such as indexes produced by
compiler-backed indexers, and heurstics, such as indexes produced by local
syntax-directed analysis for scope rules.
"""

from collections import abc as _abc
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf.internal import containers as _containers
from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
import builtins as _builtins
import sys
import typing as _typing

if sys.version_info >= (3, 10):
    from typing import TypeAlias as _TypeAlias
else:
    from typing_extensions import TypeAlias as _TypeAlias

if sys.version_info >= (3, 13):
    from warnings import deprecated as _deprecated
else:
    from typing_extensions import deprecated as _deprecated

DESCRIPTOR: _descriptor.FileDescriptor

class _ProtocolVersion:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _ProtocolVersionEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_ProtocolVersion.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    UnspecifiedProtocolVersion: _ProtocolVersion.ValueType  # 0

class ProtocolVersion(_ProtocolVersion, metaclass=_ProtocolVersionEnumTypeWrapper): ...

UnspecifiedProtocolVersion: ProtocolVersion.ValueType  # 0
Global___ProtocolVersion: _TypeAlias = ProtocolVersion  # noqa: Y015

class _TextEncoding:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _TextEncodingEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_TextEncoding.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    UnspecifiedTextEncoding: _TextEncoding.ValueType  # 0
    UTF8: _TextEncoding.ValueType  # 1
    UTF16: _TextEncoding.ValueType  # 2

class TextEncoding(_TextEncoding, metaclass=_TextEncodingEnumTypeWrapper): ...

UnspecifiedTextEncoding: TextEncoding.ValueType  # 0
UTF8: TextEncoding.ValueType  # 1
UTF16: TextEncoding.ValueType  # 2
Global___TextEncoding: _TypeAlias = TextEncoding  # noqa: Y015

class _PositionEncoding:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _PositionEncodingEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_PositionEncoding.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    UnspecifiedPositionEncoding: _PositionEncoding.ValueType  # 0
    """Default value. This value should not be used by new SCIP indexers
    so that a consumer can process the SCIP index without ambiguity.
    """
    UTF8CodeUnitOffsetFromLineStart: _PositionEncoding.ValueType  # 1
    """The 'character' value is interpreted as an offset in terms
    of UTF-8 code units (i.e. bytes).

    Example: For the string "ðŸš€ Woo" in UTF-8, the bytes are
    [240, 159, 154, 128, 32, 87, 111, 111], so the offset for 'W'
    would be 5.
    """
    UTF16CodeUnitOffsetFromLineStart: _PositionEncoding.ValueType  # 2
    """The 'character' value is interpreted as an offset in terms
    of UTF-16 code units (each is 2 bytes).

    Example: For the string "ðŸš€ Woo", the UTF-16 code units are
    ['\\ud83d', '\\ude80', ' ', 'W', 'o', 'o'], so the offset for 'W'
    would be 3.
    """
    UTF32CodeUnitOffsetFromLineStart: _PositionEncoding.ValueType  # 3
    """The 'character' value is interpreted as an offset in terms
    of UTF-32 code units (each is 4 bytes).

    Example: For the string "ðŸš€ Woo", the UTF-32 code units are
    ['ðŸš€', ' ', 'W', 'o', 'o'], so the offset for 'W' would be 2.
    """

class PositionEncoding(_PositionEncoding, metaclass=_PositionEncodingEnumTypeWrapper):
    """Encoding used to interpret the 'character' value in source ranges."""

UnspecifiedPositionEncoding: PositionEncoding.ValueType  # 0
"""Default value. This value should not be used by new SCIP indexers
so that a consumer can process the SCIP index without ambiguity.
"""
UTF8CodeUnitOffsetFromLineStart: PositionEncoding.ValueType  # 1
"""The 'character' value is interpreted as an offset in terms
of UTF-8 code units (i.e. bytes).

Example: For the string "ðŸš€ Woo" in UTF-8, the bytes are
[240, 159, 154, 128, 32, 87, 111, 111], so the offset for 'W'
would be 5.
"""
UTF16CodeUnitOffsetFromLineStart: PositionEncoding.ValueType  # 2
"""The 'character' value is interpreted as an offset in terms
of UTF-16 code units (each is 2 bytes).

Example: For the string "ðŸš€ Woo", the UTF-16 code units are
['\\ud83d', '\\ude80', ' ', 'W', 'o', 'o'], so the offset for 'W'
would be 3.
"""
UTF32CodeUnitOffsetFromLineStart: PositionEncoding.ValueType  # 3
"""The 'character' value is interpreted as an offset in terms
of UTF-32 code units (each is 4 bytes).

Example: For the string "ðŸš€ Woo", the UTF-32 code units are
['ðŸš€', ' ', 'W', 'o', 'o'], so the offset for 'W' would be 2.
"""
Global___PositionEncoding: _TypeAlias = PositionEncoding  # noqa: Y015

class _SymbolRole:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _SymbolRoleEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_SymbolRole.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    UnspecifiedSymbolRole: _SymbolRole.ValueType  # 0
    """This case is not meant to be used; it only exists to avoid an error
    from the Protobuf code generator.
    """
    Definition: _SymbolRole.ValueType  # 1
    """Is the symbol defined here? If not, then this is a symbol reference."""
    Import: _SymbolRole.ValueType  # 2
    """Is the symbol imported here?"""
    WriteAccess: _SymbolRole.ValueType  # 4
    """Is the symbol written here?"""
    ReadAccess: _SymbolRole.ValueType  # 8
    """Is the symbol read here?"""
    Generated: _SymbolRole.ValueType  # 16
    """Is the symbol in generated code?"""
    Test: _SymbolRole.ValueType  # 32
    """Is the symbol in test code?"""
    ForwardDefinition: _SymbolRole.ValueType  # 64
    """Is this a signature for a symbol that is defined elsewhere?

    Applies to forward declarations for languages like C, C++
    and Objective-C, as well as `val` declarations in interface
    files in languages like SML and OCaml.
    """

class SymbolRole(_SymbolRole, metaclass=_SymbolRoleEnumTypeWrapper):
    """SymbolRole declares what "role" a symbol has in an occurrence. A role is
    encoded as a bitset where each bit represents a different role. For example,
    to determine if the `Import` role is set, test whether the second bit of the
    enum value is defined. In pseudocode, this can be implemented with the
    logic: `const isImportRole = (role.value & SymbolRole.Import.value) > 0`.
    """

UnspecifiedSymbolRole: SymbolRole.ValueType  # 0
"""This case is not meant to be used; it only exists to avoid an error
from the Protobuf code generator.
"""
Definition: SymbolRole.ValueType  # 1
"""Is the symbol defined here? If not, then this is a symbol reference."""
Import: SymbolRole.ValueType  # 2
"""Is the symbol imported here?"""
WriteAccess: SymbolRole.ValueType  # 4
"""Is the symbol written here?"""
ReadAccess: SymbolRole.ValueType  # 8
"""Is the symbol read here?"""
Generated: SymbolRole.ValueType  # 16
"""Is the symbol in generated code?"""
Test: SymbolRole.ValueType  # 32
"""Is the symbol in test code?"""
ForwardDefinition: SymbolRole.ValueType  # 64
"""Is this a signature for a symbol that is defined elsewhere?

Applies to forward declarations for languages like C, C++
and Objective-C, as well as `val` declarations in interface
files in languages like SML and OCaml.
"""
Global___SymbolRole: _TypeAlias = SymbolRole  # noqa: Y015

class _SyntaxKind:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _SyntaxKindEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_SyntaxKind.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    UnspecifiedSyntaxKind: _SyntaxKind.ValueType  # 0
    Comment: _SyntaxKind.ValueType  # 1
    """Comment, including comment markers and text"""
    PunctuationDelimiter: _SyntaxKind.ValueType  # 2
    """`;` `.` `,`"""
    PunctuationBracket: _SyntaxKind.ValueType  # 3
    """(), {}, [] when used syntactically"""
    Keyword: _SyntaxKind.ValueType  # 4
    """`if`, `else`, `return`, `class`, etc."""
    @_builtins.property
    @_deprecated("""This enum value has been marked as deprecated using proto enum value options.""")
    def IdentifierKeyword(self) -> _SyntaxKind.ValueType: ...  # 4
    IdentifierOperator: _SyntaxKind.ValueType  # 5
    """`+`, `*`, etc."""
    Identifier: _SyntaxKind.ValueType  # 6
    """non-specific catch-all for any identifier not better described elsewhere"""
    IdentifierBuiltin: _SyntaxKind.ValueType  # 7
    """Identifiers builtin to the language: `min`, `print` in Python."""
    IdentifierNull: _SyntaxKind.ValueType  # 8
    """Identifiers representing `null`-like values: `None` in Python, `nil` in Go."""
    IdentifierConstant: _SyntaxKind.ValueType  # 9
    """`xyz` in `const xyz = "hello"`"""
    IdentifierMutableGlobal: _SyntaxKind.ValueType  # 10
    """`var X = "hello"` in Go"""
    IdentifierParameter: _SyntaxKind.ValueType  # 11
    """Parameter definition and references"""
    IdentifierLocal: _SyntaxKind.ValueType  # 12
    """Identifiers for variable definitions and references within a local scope"""
    IdentifierShadowed: _SyntaxKind.ValueType  # 13
    """Identifiers that shadow other identifiers in an outer scope"""
    IdentifierNamespace: _SyntaxKind.ValueType  # 14
    """Identifier representing a unit of code abstraction and/or namespacing.

    NOTE: This corresponds to a package in Go and JVM languages,
    and a module in languages like Python and JavaScript.
    """
    @_builtins.property
    @_deprecated("""This enum value has been marked as deprecated using proto enum value options.""")
    def IdentifierModule(self) -> _SyntaxKind.ValueType: ...  # 14
    IdentifierFunction: _SyntaxKind.ValueType  # 15
    """Function references, including calls"""
    IdentifierFunctionDefinition: _SyntaxKind.ValueType  # 16
    """Function definition only"""
    IdentifierMacro: _SyntaxKind.ValueType  # 17
    """Macro references, including invocations"""
    IdentifierMacroDefinition: _SyntaxKind.ValueType  # 18
    """Macro definition only"""
    IdentifierType: _SyntaxKind.ValueType  # 19
    """non-builtin types"""
    IdentifierBuiltinType: _SyntaxKind.ValueType  # 20
    """builtin types only, such as `str` for Python or `int` in Go"""
    IdentifierAttribute: _SyntaxKind.ValueType  # 21
    """Python decorators, c-like __attribute__"""
    RegexEscape: _SyntaxKind.ValueType  # 22
    """`\\b`"""
    RegexRepeated: _SyntaxKind.ValueType  # 23
    """`*`, `+`"""
    RegexWildcard: _SyntaxKind.ValueType  # 24
    """`.`"""
    RegexDelimiter: _SyntaxKind.ValueType  # 25
    """`(`, `)`, `[`, `]`"""
    RegexJoin: _SyntaxKind.ValueType  # 26
    """`|`, `-`"""
    StringLiteral: _SyntaxKind.ValueType  # 27
    """Literal strings: "Hello, world!" """
    StringLiteralEscape: _SyntaxKind.ValueType  # 28
    """non-regex escapes: "\\t", "\\n" """
    StringLiteralSpecial: _SyntaxKind.ValueType  # 29
    """datetimes within strings, special words within a string, `{}` in format strings"""
    StringLiteralKey: _SyntaxKind.ValueType  # 30
    """"key" in { "key": "value" }, useful for example in JSON"""
    CharacterLiteral: _SyntaxKind.ValueType  # 31
    """'c' or similar, in languages that differentiate strings and characters"""
    NumericLiteral: _SyntaxKind.ValueType  # 32
    """Literal numbers, both floats and integers"""
    BooleanLiteral: _SyntaxKind.ValueType  # 33
    """`true`, `false`"""
    Tag: _SyntaxKind.ValueType  # 34
    """Used for XML-like tags"""
    TagAttribute: _SyntaxKind.ValueType  # 35
    """Attribute name in XML-like tags"""
    TagDelimiter: _SyntaxKind.ValueType  # 36
    """Delimiters for XML-like tags"""

class SyntaxKind(_SyntaxKind, metaclass=_SyntaxKindEnumTypeWrapper): ...

UnspecifiedSyntaxKind: SyntaxKind.ValueType  # 0
Comment: SyntaxKind.ValueType  # 1
"""Comment, including comment markers and text"""
PunctuationDelimiter: SyntaxKind.ValueType  # 2
"""`;` `.` `,`"""
PunctuationBracket: SyntaxKind.ValueType  # 3
"""(), {}, [] when used syntactically"""
Keyword: SyntaxKind.ValueType  # 4
"""`if`, `else`, `return`, `class`, etc."""
IdentifierKeyword: SyntaxKind.ValueType  # 4
IdentifierOperator: SyntaxKind.ValueType  # 5
"""`+`, `*`, etc."""
Identifier: SyntaxKind.ValueType  # 6
"""non-specific catch-all for any identifier not better described elsewhere"""
IdentifierBuiltin: SyntaxKind.ValueType  # 7
"""Identifiers builtin to the language: `min`, `print` in Python."""
IdentifierNull: SyntaxKind.ValueType  # 8
"""Identifiers representing `null`-like values: `None` in Python, `nil` in Go."""
IdentifierConstant: SyntaxKind.ValueType  # 9
"""`xyz` in `const xyz = "hello"`"""
IdentifierMutableGlobal: SyntaxKind.ValueType  # 10
"""`var X = "hello"` in Go"""
IdentifierParameter: SyntaxKind.ValueType  # 11
"""Parameter definition and references"""
IdentifierLocal: SyntaxKind.ValueType  # 12
"""Identifiers for variable definitions and references within a local scope"""
IdentifierShadowed: SyntaxKind.ValueType  # 13
"""Identifiers that shadow other identifiers in an outer scope"""
IdentifierNamespace: SyntaxKind.ValueType  # 14
"""Identifier representing a unit of code abstraction and/or namespacing.

NOTE: This corresponds to a package in Go and JVM languages,
and a module in languages like Python and JavaScript.
"""
IdentifierModule: SyntaxKind.ValueType  # 14
IdentifierFunction: SyntaxKind.ValueType  # 15
"""Function references, including calls"""
IdentifierFunctionDefinition: SyntaxKind.ValueType  # 16
"""Function definition only"""
IdentifierMacro: SyntaxKind.ValueType  # 17
"""Macro references, including invocations"""
IdentifierMacroDefinition: SyntaxKind.ValueType  # 18
"""Macro definition only"""
IdentifierType: SyntaxKind.ValueType  # 19
"""non-builtin types"""
IdentifierBuiltinType: SyntaxKind.ValueType  # 20
"""builtin types only, such as `str` for Python or `int` in Go"""
IdentifierAttribute: SyntaxKind.ValueType  # 21
"""Python decorators, c-like __attribute__"""
RegexEscape: SyntaxKind.ValueType  # 22
"""`\\b`"""
RegexRepeated: SyntaxKind.ValueType  # 23
"""`*`, `+`"""
RegexWildcard: SyntaxKind.ValueType  # 24
"""`.`"""
RegexDelimiter: SyntaxKind.ValueType  # 25
"""`(`, `)`, `[`, `]`"""
RegexJoin: SyntaxKind.ValueType  # 26
"""`|`, `-`"""
StringLiteral: SyntaxKind.ValueType  # 27
"""Literal strings: "Hello, world!" """
StringLiteralEscape: SyntaxKind.ValueType  # 28
"""non-regex escapes: "\\t", "\\n" """
StringLiteralSpecial: SyntaxKind.ValueType  # 29
"""datetimes within strings, special words within a string, `{}` in format strings"""
StringLiteralKey: SyntaxKind.ValueType  # 30
""""key" in { "key": "value" }, useful for example in JSON"""
CharacterLiteral: SyntaxKind.ValueType  # 31
"""'c' or similar, in languages that differentiate strings and characters"""
NumericLiteral: SyntaxKind.ValueType  # 32
"""Literal numbers, both floats and integers"""
BooleanLiteral: SyntaxKind.ValueType  # 33
"""`true`, `false`"""
Tag: SyntaxKind.ValueType  # 34
"""Used for XML-like tags"""
TagAttribute: SyntaxKind.ValueType  # 35
"""Attribute name in XML-like tags"""
TagDelimiter: SyntaxKind.ValueType  # 36
"""Delimiters for XML-like tags"""
Global___SyntaxKind: _TypeAlias = SyntaxKind  # noqa: Y015

class _Severity:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _SeverityEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_Severity.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    UnspecifiedSeverity: _Severity.ValueType  # 0
    Error: _Severity.ValueType  # 1
    Warning: _Severity.ValueType  # 2
    Information: _Severity.ValueType  # 3
    Hint: _Severity.ValueType  # 4

class Severity(_Severity, metaclass=_SeverityEnumTypeWrapper): ...

UnspecifiedSeverity: Severity.ValueType  # 0
Error: Severity.ValueType  # 1
Warning: Severity.ValueType  # 2
Information: Severity.ValueType  # 3
Hint: Severity.ValueType  # 4
Global___Severity: _TypeAlias = Severity  # noqa: Y015

class _DiagnosticTag:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _DiagnosticTagEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_DiagnosticTag.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    UnspecifiedDiagnosticTag: _DiagnosticTag.ValueType  # 0
    Unnecessary: _DiagnosticTag.ValueType  # 1
    Deprecated: _DiagnosticTag.ValueType  # 2

class DiagnosticTag(_DiagnosticTag, metaclass=_DiagnosticTagEnumTypeWrapper): ...

UnspecifiedDiagnosticTag: DiagnosticTag.ValueType  # 0
Unnecessary: DiagnosticTag.ValueType  # 1
Deprecated: DiagnosticTag.ValueType  # 2
Global___DiagnosticTag: _TypeAlias = DiagnosticTag  # noqa: Y015

class _Language:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _LanguageEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_Language.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    UnspecifiedLanguage: _Language.ValueType  # 0
    ABAP: _Language.ValueType  # 60
    Apex: _Language.ValueType  # 96
    APL: _Language.ValueType  # 49
    Ada: _Language.ValueType  # 39
    Agda: _Language.ValueType  # 45
    AsciiDoc: _Language.ValueType  # 86
    Assembly: _Language.ValueType  # 58
    Awk: _Language.ValueType  # 66
    Bat: _Language.ValueType  # 68
    BibTeX: _Language.ValueType  # 81
    C: _Language.ValueType  # 34
    COBOL: _Language.ValueType  # 59
    CPP: _Language.ValueType  # 35
    """C++ (the name "CPP" was chosen for consistency with LSP)"""
    CSS: _Language.ValueType  # 26
    CSharp: _Language.ValueType  # 1
    Clojure: _Language.ValueType  # 8
    Coffeescript: _Language.ValueType  # 21
    CommonLisp: _Language.ValueType  # 9
    Coq: _Language.ValueType  # 47
    CUDA: _Language.ValueType  # 97
    Dart: _Language.ValueType  # 3
    Delphi: _Language.ValueType  # 57
    Diff: _Language.ValueType  # 88
    Dockerfile: _Language.ValueType  # 80
    Dyalog: _Language.ValueType  # 50
    Elixir: _Language.ValueType  # 17
    Erlang: _Language.ValueType  # 18
    FSharp: _Language.ValueType  # 42
    Fish: _Language.ValueType  # 65
    Flow: _Language.ValueType  # 24
    Fortran: _Language.ValueType  # 56
    Git_Commit: _Language.ValueType  # 91
    Git_Config: _Language.ValueType  # 89
    Git_Rebase: _Language.ValueType  # 92
    Go: _Language.ValueType  # 33
    GraphQL: _Language.ValueType  # 98
    Groovy: _Language.ValueType  # 7
    HTML: _Language.ValueType  # 30
    Hack: _Language.ValueType  # 20
    Handlebars: _Language.ValueType  # 90
    Haskell: _Language.ValueType  # 44
    Idris: _Language.ValueType  # 46
    Ini: _Language.ValueType  # 72
    J: _Language.ValueType  # 51
    JSON: _Language.ValueType  # 75
    Java: _Language.ValueType  # 6
    JavaScript: _Language.ValueType  # 22
    JavaScriptReact: _Language.ValueType  # 93
    Jsonnet: _Language.ValueType  # 76
    Julia: _Language.ValueType  # 55
    Justfile: _Language.ValueType  # 109
    Kotlin: _Language.ValueType  # 4
    LaTeX: _Language.ValueType  # 83
    Lean: _Language.ValueType  # 48
    Less: _Language.ValueType  # 27
    Lua: _Language.ValueType  # 12
    Luau: _Language.ValueType  # 108
    Makefile: _Language.ValueType  # 79
    Markdown: _Language.ValueType  # 84
    Matlab: _Language.ValueType  # 52
    Nickel: _Language.ValueType  # 110
    """https://nickel-lang.org/"""
    Nix: _Language.ValueType  # 77
    OCaml: _Language.ValueType  # 41
    Objective_C: _Language.ValueType  # 36
    Objective_CPP: _Language.ValueType  # 37
    Pascal: _Language.ValueType  # 99
    PHP: _Language.ValueType  # 19
    PLSQL: _Language.ValueType  # 70
    Perl: _Language.ValueType  # 13
    PowerShell: _Language.ValueType  # 67
    Prolog: _Language.ValueType  # 71
    Protobuf: _Language.ValueType  # 100
    Python: _Language.ValueType  # 15
    R: _Language.ValueType  # 54
    Racket: _Language.ValueType  # 11
    Raku: _Language.ValueType  # 14
    Razor: _Language.ValueType  # 62
    Repro: _Language.ValueType  # 102
    """Internal language for testing SCIP"""
    ReST: _Language.ValueType  # 85
    Ruby: _Language.ValueType  # 16
    Rust: _Language.ValueType  # 40
    SAS: _Language.ValueType  # 61
    SCSS: _Language.ValueType  # 29
    SML: _Language.ValueType  # 43
    SQL: _Language.ValueType  # 69
    Sass: _Language.ValueType  # 28
    Scala: _Language.ValueType  # 5
    Scheme: _Language.ValueType  # 10
    ShellScript: _Language.ValueType  # 64
    """Bash"""
    Skylark: _Language.ValueType  # 78
    Slang: _Language.ValueType  # 107
    Solidity: _Language.ValueType  # 95
    Svelte: _Language.ValueType  # 106
    Swift: _Language.ValueType  # 2
    Tcl: _Language.ValueType  # 101
    TOML: _Language.ValueType  # 73
    TeX: _Language.ValueType  # 82
    Thrift: _Language.ValueType  # 103
    TypeScript: _Language.ValueType  # 23
    TypeScriptReact: _Language.ValueType  # 94
    Verilog: _Language.ValueType  # 104
    VHDL: _Language.ValueType  # 105
    VisualBasic: _Language.ValueType  # 63
    Vue: _Language.ValueType  # 25
    Wolfram: _Language.ValueType  # 53
    XML: _Language.ValueType  # 31
    XSL: _Language.ValueType  # 32
    YAML: _Language.ValueType  # 74
    Zig: _Language.ValueType  # 38
    """NextLanguage = 111;
    Steps add a new language:
    1. Copy-paste the "NextLanguage = N" line above
    2. Increment "NextLanguage = N" to "NextLanguage = N+1"
    3. Replace "NextLanguage = N" with the name of the new language.
    4. Move the new language to the correct line above using alphabetical order
    5. (optional) Add a brief comment behind the language if the name is not self-explanatory
    """

class Language(_Language, metaclass=_LanguageEnumTypeWrapper):
    """Language standardises names of common programming languages that can be used
    for the `Document.language` field. The primary purpose of this enum is to
    prevent a situation where we have a single programming language ends up with
    multiple string representations. For example, the C++ language uses the name
    "CPP" in this enum and other names such as "cpp" are incompatible.
    Feel free to send a pull-request to add missing programming languages.
    """

UnspecifiedLanguage: Language.ValueType  # 0
ABAP: Language.ValueType  # 60
Apex: Language.ValueType  # 96
APL: Language.ValueType  # 49
Ada: Language.ValueType  # 39
Agda: Language.ValueType  # 45
AsciiDoc: Language.ValueType  # 86
Assembly: Language.ValueType  # 58
Awk: Language.ValueType  # 66
Bat: Language.ValueType  # 68
BibTeX: Language.ValueType  # 81
C: Language.ValueType  # 34
COBOL: Language.ValueType  # 59
CPP: Language.ValueType  # 35
"""C++ (the name "CPP" was chosen for consistency with LSP)"""
CSS: Language.ValueType  # 26
CSharp: Language.ValueType  # 1
Clojure: Language.ValueType  # 8
Coffeescript: Language.ValueType  # 21
CommonLisp: Language.ValueType  # 9
Coq: Language.ValueType  # 47
CUDA: Language.ValueType  # 97
Dart: Language.ValueType  # 3
Delphi: Language.ValueType  # 57
Diff: Language.ValueType  # 88
Dockerfile: Language.ValueType  # 80
Dyalog: Language.ValueType  # 50
Elixir: Language.ValueType  # 17
Erlang: Language.ValueType  # 18
FSharp: Language.ValueType  # 42
Fish: Language.ValueType  # 65
Flow: Language.ValueType  # 24
Fortran: Language.ValueType  # 56
Git_Commit: Language.ValueType  # 91
Git_Config: Language.ValueType  # 89
Git_Rebase: Language.ValueType  # 92
Go: Language.ValueType  # 33
GraphQL: Language.ValueType  # 98
Groovy: Language.ValueType  # 7
HTML: Language.ValueType  # 30
Hack: Language.ValueType  # 20
Handlebars: Language.ValueType  # 90
Haskell: Language.ValueType  # 44
Idris: Language.ValueType  # 46
Ini: Language.ValueType  # 72
J: Language.ValueType  # 51
JSON: Language.ValueType  # 75
Java: Language.ValueType  # 6
JavaScript: Language.ValueType  # 22
JavaScriptReact: Language.ValueType  # 93
Jsonnet: Language.ValueType  # 76
Julia: Language.ValueType  # 55
Justfile: Language.ValueType  # 109
Kotlin: Language.ValueType  # 4
LaTeX: Language.ValueType  # 83
Lean: Language.ValueType  # 48
Less: Language.ValueType  # 27
Lua: Language.ValueType  # 12
Luau: Language.ValueType  # 108
Makefile: Language.ValueType  # 79
Markdown: Language.ValueType  # 84
Matlab: Language.ValueType  # 52
Nickel: Language.ValueType  # 110
"""https://nickel-lang.org/"""
Nix: Language.ValueType  # 77
OCaml: Language.ValueType  # 41
Objective_C: Language.ValueType  # 36
Objective_CPP: Language.ValueType  # 37
Pascal: Language.ValueType  # 99
PHP: Language.ValueType  # 19
PLSQL: Language.ValueType  # 70
Perl: Language.ValueType  # 13
PowerShell: Language.ValueType  # 67
Prolog: Language.ValueType  # 71
Protobuf: Language.ValueType  # 100
Python: Language.ValueType  # 15
R: Language.ValueType  # 54
Racket: Language.ValueType  # 11
Raku: Language.ValueType  # 14
Razor: Language.ValueType  # 62
Repro: Language.ValueType  # 102
"""Internal language for testing SCIP"""
ReST: Language.ValueType  # 85
Ruby: Language.ValueType  # 16
Rust: Language.ValueType  # 40
SAS: Language.ValueType  # 61
SCSS: Language.ValueType  # 29
SML: Language.ValueType  # 43
SQL: Language.ValueType  # 69
Sass: Language.ValueType  # 28
Scala: Language.ValueType  # 5
Scheme: Language.ValueType  # 10
ShellScript: Language.ValueType  # 64
"""Bash"""
Skylark: Language.ValueType  # 78
Slang: Language.ValueType  # 107
Solidity: Language.ValueType  # 95
Svelte: Language.ValueType  # 106
Swift: Language.ValueType  # 2
Tcl: Language.ValueType  # 101
TOML: Language.ValueType  # 73
TeX: Language.ValueType  # 82
Thrift: Language.ValueType  # 103
TypeScript: Language.ValueType  # 23
TypeScriptReact: Language.ValueType  # 94
Verilog: Language.ValueType  # 104
VHDL: Language.ValueType  # 105
VisualBasic: Language.ValueType  # 63
Vue: Language.ValueType  # 25
Wolfram: Language.ValueType  # 53
XML: Language.ValueType  # 31
XSL: Language.ValueType  # 32
YAML: Language.ValueType  # 74
Zig: Language.ValueType  # 38
"""NextLanguage = 111;
Steps add a new language:
1. Copy-paste the "NextLanguage = N" line above
2. Increment "NextLanguage = N" to "NextLanguage = N+1"
3. Replace "NextLanguage = N" with the name of the new language.
4. Move the new language to the correct line above using alphabetical order
5. (optional) Add a brief comment behind the language if the name is not self-explanatory
"""
Global___Language: _TypeAlias = Language  # noqa: Y015

@_typing.final
class Index(_message.Message):
    """Index represents a complete SCIP index for a workspace this is rooted at a
    single directory. An Index message payload can have a large memory footprint
    and it's therefore recommended to emit and consume an Index payload one field
    value at a time. To permit streaming consumption of an Index payload, the
    `metadata` field must appear at the start of the stream and must only appear
    once in the stream. Other field values may appear in any order.
    """

    DESCRIPTOR: _descriptor.Descriptor

    METADATA_FIELD_NUMBER: _builtins.int
    DOCUMENTS_FIELD_NUMBER: _builtins.int
    EXTERNAL_SYMBOLS_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def metadata(self) -> Global___Metadata:
        """Metadata about this index."""

    @_builtins.property
    def documents(self) -> _containers.RepeatedCompositeFieldContainer[Global___Document]:
        """Documents that belong to this index."""

    @_builtins.property
    def external_symbols(self) -> _containers.RepeatedCompositeFieldContainer[Global___SymbolInformation]:
        """(optional) Symbols that are referenced from this index but are defined in
        an external package (a separate `Index` message). Leave this field empty
        if you assume the external package will get indexed separately. If the
        external package won't get indexed for some reason then you can use this
        field to provide hover documentation for those external symbols.
        IMPORTANT: When adding a new field to `Index` here, add a matching
        function in `IndexVisitor` and update `ParseStreaming`.
        """

    def __init__(
        self,
        *,
        metadata: Global___Metadata | None = ...,
        documents: _abc.Iterable[Global___Document] | None = ...,
        external_symbols: _abc.Iterable[Global___SymbolInformation] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["metadata", b"metadata"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["documents", b"documents", "external_symbols", b"external_symbols", "metadata", b"metadata"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Index: _TypeAlias = Index  # noqa: Y015

@_typing.final
class Metadata(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    VERSION_FIELD_NUMBER: _builtins.int
    TOOL_INFO_FIELD_NUMBER: _builtins.int
    PROJECT_ROOT_FIELD_NUMBER: _builtins.int
    TEXT_DOCUMENT_ENCODING_FIELD_NUMBER: _builtins.int
    version: Global___ProtocolVersion.ValueType
    """Which version of this protocol was used to generate this index?"""
    project_root: _builtins.str
    """URI-encoded absolute path to the root directory of this index. All
    documents in this index must appear in a subdirectory of this root
    directory.
    """
    text_document_encoding: Global___TextEncoding.ValueType
    """Text encoding of the source files on disk that are referenced from
    `Document.relative_path`. This value is unrelated to the `Document.text`
    field, which is a Protobuf string and hence must be UTF-8 encoded.
    """
    @_builtins.property
    def tool_info(self) -> Global___ToolInfo:
        """Information about the tool that produced this index."""

    def __init__(
        self,
        *,
        version: Global___ProtocolVersion.ValueType = ...,
        tool_info: Global___ToolInfo | None = ...,
        project_root: _builtins.str = ...,
        text_document_encoding: Global___TextEncoding.ValueType = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["tool_info", b"tool_info"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["project_root", b"project_root", "text_document_encoding", b"text_document_encoding", "tool_info", b"tool_info", "version", b"version"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Metadata: _TypeAlias = Metadata  # noqa: Y015

@_typing.final
class ToolInfo(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    NAME_FIELD_NUMBER: _builtins.int
    VERSION_FIELD_NUMBER: _builtins.int
    ARGUMENTS_FIELD_NUMBER: _builtins.int
    name: _builtins.str
    """Name of the indexer that produced this index."""
    version: _builtins.str
    """Version of the indexer that produced this index."""
    @_builtins.property
    def arguments(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
        """Command-line arguments that were used to invoke this indexer."""

    def __init__(
        self,
        *,
        name: _builtins.str = ...,
        version: _builtins.str = ...,
        arguments: _abc.Iterable[_builtins.str] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["arguments", b"arguments", "name", b"name", "version", b"version"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ToolInfo: _TypeAlias = ToolInfo  # noqa: Y015

@_typing.final
class Document(_message.Message):
    """Document defines the metadata about a source file on disk."""

    DESCRIPTOR: _descriptor.Descriptor

    LANGUAGE_FIELD_NUMBER: _builtins.int
    RELATIVE_PATH_FIELD_NUMBER: _builtins.int
    OCCURRENCES_FIELD_NUMBER: _builtins.int
    SYMBOLS_FIELD_NUMBER: _builtins.int
    TEXT_FIELD_NUMBER: _builtins.int
    POSITION_ENCODING_FIELD_NUMBER: _builtins.int
    language: _builtins.str
    """The string ID for the programming language this file is written in.
    The `Language` enum contains the names of most common programming languages.
    This field is typed as a string to permit any programming language, including
    ones that are not specified by the `Language` enum.
    """
    relative_path: _builtins.str
    """(Required) Unique path to the text document.

    1. The path must be relative to the directory supplied in the associated
       `Metadata.project_root`.
    2. The path must not begin with a leading '/'.
    3. The path must point to a regular file, not a symbolic link.
    4. The path must use '/' as the separator, including on Windows.
    5. The path must be canonical; it cannot include empty components ('//'),
       or '.' or '..'.
    """
    text: _builtins.str
    """(optional) Text contents of the this document. Indexers are not expected to
    include the text by default. It's preferrable that clients read the text
    contents from the file system by resolving the absolute path from joining
    `Index.metadata.project_root` and `Document.relative_path`. This field was
    introduced to support `SymbolInformation.signature_documentation`, but it
    can be used for other purposes as well, for example testing or when working
    with virtual/in-memory documents.
    """
    position_encoding: Global___PositionEncoding.ValueType
    """Specifies the encoding used for source ranges in this Document.

    Usually, this will match the type used to index the string type
    in the indexer's implementation language in O(1) time.
    - For an indexer implemented in JVM/.NET language or JavaScript/TypeScript,
      use UTF16CodeUnitOffsetFromLineStart.
    - For an indexer implemented in Python,
      use UTF32CodeUnitOffsetFromLineStart.
    - For an indexer implemented in Go, Rust or C++,
      use UTF8ByteOffsetFromLineStart.
    """
    @_builtins.property
    def occurrences(self) -> _containers.RepeatedCompositeFieldContainer[Global___Occurrence]:
        """Occurrences that appear in this file."""

    @_builtins.property
    def symbols(self) -> _containers.RepeatedCompositeFieldContainer[Global___SymbolInformation]:
        """Symbols that are "defined" within this document.

        This should include symbols which technically do not have any definition,
        but have a reference and are defined by some other symbol (see
        Relationship.is_definition).
        """

    def __init__(
        self,
        *,
        language: _builtins.str = ...,
        relative_path: _builtins.str = ...,
        occurrences: _abc.Iterable[Global___Occurrence] | None = ...,
        symbols: _abc.Iterable[Global___SymbolInformation] | None = ...,
        text: _builtins.str = ...,
        position_encoding: Global___PositionEncoding.ValueType = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["language", b"language", "occurrences", b"occurrences", "position_encoding", b"position_encoding", "relative_path", b"relative_path", "symbols", b"symbols", "text", b"text"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Document: _TypeAlias = Document  # noqa: Y015

@_typing.final
class Symbol(_message.Message):
    """Symbol is similar to a URI, it identifies a class, method, or a local
    variable. `SymbolInformation` contains rich metadata about symbols such as
    the docstring.

    Symbol has a standardized string representation, which can be used
    interchangeably with `Symbol`. The syntax for Symbol is the following:
    ```
    # (<x>)+ stands for one or more repetitions of <x>
    # (<x>)? stands for zero or one occurrence of <x>
    <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>
    <package>              ::= <manager> ' ' <package-name> ' ' <version>
    <scheme>               ::= any UTF-8, escape spaces with double space. Must not be empty nor start with 'local'
    <manager>              ::= any UTF-8, escape spaces with double space. Use the placeholder '.' to indicate an empty value
    <package-name>         ::= same as above
    <version>              ::= same as above
    <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>
    <namespace>            ::= <name> '/'
    <type>                 ::= <name> '#'
    <term>                 ::= <name> '.'
    <meta>                 ::= <name> ':'
    <macro>                ::= <name> '!'
    <method>               ::= <name> '(' (<method-disambiguator>)? ').'
    <type-parameter>       ::= '[' <name> ']'
    <parameter>            ::= '(' <name> ')'
    <name>                 ::= <identifier>
    <method-disambiguator> ::= <simple-identifier>
    <identifier>           ::= <simple-identifier> | <escaped-identifier>
    <simple-identifier>    ::= (<identifier-character>)+
    <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit
    <escaped-identifier>   ::= '`' (<escaped-character>)+ '`', must contain at least one non-<identifier-character>
    <escaped-characters>   ::= any UTF-8, escape backticks with double backtick.
    <local-id>             ::= <simple-identifier>
    ```

    The list of descriptors for a symbol should together form a fully
    qualified name for the symbol. That is, it should serve as a unique
    identifier across the package. Typically, it will include one descriptor
    for every node in the AST (along the ancestry path) between the root of
    the file and the node corresponding to the symbol.

    Local symbols MUST only be used for entities which are local to a Document,
    and cannot be accessed from outside the Document.
    """

    DESCRIPTOR: _descriptor.Descriptor

    SCHEME_FIELD_NUMBER: _builtins.int
    PACKAGE_FIELD_NUMBER: _builtins.int
    DESCRIPTORS_FIELD_NUMBER: _builtins.int
    scheme: _builtins.str
    @_builtins.property
    def package(self) -> Global___Package: ...
    @_builtins.property
    def descriptors(self) -> _containers.RepeatedCompositeFieldContainer[Global___Descriptor]: ...
    def __init__(
        self,
        *,
        scheme: _builtins.str = ...,
        package: Global___Package | None = ...,
        descriptors: _abc.Iterable[Global___Descriptor] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["package", b"package"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["descriptors", b"descriptors", "package", b"package", "scheme", b"scheme"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Symbol: _TypeAlias = Symbol  # noqa: Y015

@_typing.final
class Package(_message.Message):
    """Unit of packaging and distribution.

    NOTE: This corresponds to a module in Go and JVM languages.
    """

    DESCRIPTOR: _descriptor.Descriptor

    MANAGER_FIELD_NUMBER: _builtins.int
    NAME_FIELD_NUMBER: _builtins.int
    VERSION_FIELD_NUMBER: _builtins.int
    manager: _builtins.str
    name: _builtins.str
    version: _builtins.str
    def __init__(
        self,
        *,
        manager: _builtins.str = ...,
        name: _builtins.str = ...,
        version: _builtins.str = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["manager", b"manager", "name", b"name", "version", b"version"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Package: _TypeAlias = Package  # noqa: Y015

@_typing.final
class Descriptor(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    class _Suffix:
        ValueType = _typing.NewType("ValueType", _builtins.int)
        V: _TypeAlias = ValueType  # noqa: Y015

    class _SuffixEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[Descriptor._Suffix.ValueType], _builtins.type):
        DESCRIPTOR: _descriptor.EnumDescriptor
        UnspecifiedSuffix: Descriptor._Suffix.ValueType  # 0
        Namespace: Descriptor._Suffix.ValueType  # 1
        """Unit of code abstraction and/or namespacing.

        NOTE: This corresponds to a package in Go and JVM languages.
        """
        @_builtins.property
        @_deprecated("""This enum value has been marked as deprecated using proto enum value options.""")
        def Package(self) -> Descriptor._Suffix.ValueType:   # 1
            """Use Namespace instead."""
        Type: Descriptor._Suffix.ValueType  # 2
        Term: Descriptor._Suffix.ValueType  # 3
        Method: Descriptor._Suffix.ValueType  # 4
        TypeParameter: Descriptor._Suffix.ValueType  # 5
        Parameter: Descriptor._Suffix.ValueType  # 6
        Meta: Descriptor._Suffix.ValueType  # 7
        """Can be used for any purpose."""
        Local: Descriptor._Suffix.ValueType  # 8
        Macro: Descriptor._Suffix.ValueType  # 9

    class Suffix(_Suffix, metaclass=_SuffixEnumTypeWrapper): ...
    UnspecifiedSuffix: Descriptor.Suffix.ValueType  # 0
    Namespace: Descriptor.Suffix.ValueType  # 1
    """Unit of code abstraction and/or namespacing.

    NOTE: This corresponds to a package in Go and JVM languages.
    """
    Package: Descriptor.Suffix.ValueType  # 1
    """Use Namespace instead."""
    Type: Descriptor.Suffix.ValueType  # 2
    Term: Descriptor.Suffix.ValueType  # 3
    Method: Descriptor.Suffix.ValueType  # 4
    TypeParameter: Descriptor.Suffix.ValueType  # 5
    Parameter: Descriptor.Suffix.ValueType  # 6
    Meta: Descriptor.Suffix.ValueType  # 7
    """Can be used for any purpose."""
    Local: Descriptor.Suffix.ValueType  # 8
    Macro: Descriptor.Suffix.ValueType  # 9

    NAME_FIELD_NUMBER: _builtins.int
    DISAMBIGUATOR_FIELD_NUMBER: _builtins.int
    SUFFIX_FIELD_NUMBER: _builtins.int
    name: _builtins.str
    disambiguator: _builtins.str
    suffix: Global___Descriptor.Suffix.ValueType
    """NOTE: If you add new fields here, make sure to update the prepareSlot()
    function responsible for parsing symbols.
    """
    def __init__(
        self,
        *,
        name: _builtins.str = ...,
        disambiguator: _builtins.str = ...,
        suffix: Global___Descriptor.Suffix.ValueType = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["disambiguator", b"disambiguator", "name", b"name", "suffix", b"suffix"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Descriptor: _TypeAlias = Descriptor  # noqa: Y015

@_typing.final
class SymbolInformation(_message.Message):
    """SymbolInformation defines metadata about a symbol, such as the symbol's
    docstring or what package it's defined it.
    """

    DESCRIPTOR: _descriptor.Descriptor

    class _Kind:
        ValueType = _typing.NewType("ValueType", _builtins.int)
        V: _TypeAlias = ValueType  # noqa: Y015

    class _KindEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[SymbolInformation._Kind.ValueType], _builtins.type):
        DESCRIPTOR: _descriptor.EnumDescriptor
        UnspecifiedKind: SymbolInformation._Kind.ValueType  # 0
        AbstractMethod: SymbolInformation._Kind.ValueType  # 66
        """A method which may or may not have a body. For Java, Kotlin etc."""
        Accessor: SymbolInformation._Kind.ValueType  # 72
        """For Ruby's attr_accessor"""
        Array: SymbolInformation._Kind.ValueType  # 1
        Assertion: SymbolInformation._Kind.ValueType  # 2
        """For Alloy"""
        AssociatedType: SymbolInformation._Kind.ValueType  # 3
        Attribute: SymbolInformation._Kind.ValueType  # 4
        """For C++"""
        Axiom: SymbolInformation._Kind.ValueType  # 5
        """For Lean"""
        Boolean: SymbolInformation._Kind.ValueType  # 6
        Class: SymbolInformation._Kind.ValueType  # 7
        Concept: SymbolInformation._Kind.ValueType  # 86
        """For C++"""
        Constant: SymbolInformation._Kind.ValueType  # 8
        Constructor: SymbolInformation._Kind.ValueType  # 9
        Contract: SymbolInformation._Kind.ValueType  # 62
        """For Solidity"""
        DataFamily: SymbolInformation._Kind.ValueType  # 10
        """For Haskell"""
        Delegate: SymbolInformation._Kind.ValueType  # 73
        """For C# and F#"""
        Enum: SymbolInformation._Kind.ValueType  # 11
        EnumMember: SymbolInformation._Kind.ValueType  # 12
        Error: SymbolInformation._Kind.ValueType  # 63
        Event: SymbolInformation._Kind.ValueType  # 13
        Extension: SymbolInformation._Kind.ValueType  # 84
        """For Dart"""
        Fact: SymbolInformation._Kind.ValueType  # 14
        """For Alloy"""
        Field: SymbolInformation._Kind.ValueType  # 15
        File: SymbolInformation._Kind.ValueType  # 16
        Function: SymbolInformation._Kind.ValueType  # 17
        Getter: SymbolInformation._Kind.ValueType  # 18
        """For 'get' in Swift, 'attr_reader' in Ruby"""
        Grammar: SymbolInformation._Kind.ValueType  # 19
        """For Raku"""
        Instance: SymbolInformation._Kind.ValueType  # 20
        """For Purescript and Lean"""
        Interface: SymbolInformation._Kind.ValueType  # 21
        Key: SymbolInformation._Kind.ValueType  # 22
        Lang: SymbolInformation._Kind.ValueType  # 23
        """For Racket"""
        Lemma: SymbolInformation._Kind.ValueType  # 24
        """For Lean"""
        Library: SymbolInformation._Kind.ValueType  # 64
        """For solidity"""
        Macro: SymbolInformation._Kind.ValueType  # 25
        Method: SymbolInformation._Kind.ValueType  # 26
        MethodAlias: SymbolInformation._Kind.ValueType  # 74
        """For Ruby"""
        MethodReceiver: SymbolInformation._Kind.ValueType  # 27
        """Analogous to 'ThisParameter' and 'SelfParameter', but for languages
        like Go where the receiver doesn't have a conventional name.
        """
        MethodSpecification: SymbolInformation._Kind.ValueType  # 67
        """Analogous to 'AbstractMethod', for Go."""
        Message: SymbolInformation._Kind.ValueType  # 28
        """For Protobuf"""
        Mixin: SymbolInformation._Kind.ValueType  # 85
        """For Dart"""
        Modifier: SymbolInformation._Kind.ValueType  # 65
        """For Solidity"""
        Module: SymbolInformation._Kind.ValueType  # 29
        Namespace: SymbolInformation._Kind.ValueType  # 30
        Null: SymbolInformation._Kind.ValueType  # 31
        Number: SymbolInformation._Kind.ValueType  # 32
        Object: SymbolInformation._Kind.ValueType  # 33
        Operator: SymbolInformation._Kind.ValueType  # 34
        Package: SymbolInformation._Kind.ValueType  # 35
        PackageObject: SymbolInformation._Kind.ValueType  # 36
        Parameter: SymbolInformation._Kind.ValueType  # 37
        ParameterLabel: SymbolInformation._Kind.ValueType  # 38
        Pattern: SymbolInformation._Kind.ValueType  # 39
        """For Haskell's PatternSynonyms"""
        Predicate: SymbolInformation._Kind.ValueType  # 40
        """For Alloy"""
        Property: SymbolInformation._Kind.ValueType  # 41
        Protocol: SymbolInformation._Kind.ValueType  # 42
        """Analogous to 'Trait' and 'TypeClass', for Swift and Objective-C"""
        ProtocolMethod: SymbolInformation._Kind.ValueType  # 68
        """Analogous to 'AbstractMethod', for Swift and Objective-C."""
        PureVirtualMethod: SymbolInformation._Kind.ValueType  # 69
        """Analogous to 'AbstractMethod', for C++."""
        Quasiquoter: SymbolInformation._Kind.ValueType  # 43
        """For Haskell"""
        SelfParameter: SymbolInformation._Kind.ValueType  # 44
        """'self' in Python, Rust, Swift etc."""
        Setter: SymbolInformation._Kind.ValueType  # 45
        """For 'set' in Swift, 'attr_writer' in Ruby"""
        Signature: SymbolInformation._Kind.ValueType  # 46
        """For Alloy, analogous to 'Struct'."""
        SingletonClass: SymbolInformation._Kind.ValueType  # 75
        """For Ruby"""
        SingletonMethod: SymbolInformation._Kind.ValueType  # 76
        """Analogous to 'StaticMethod', for Ruby."""
        StaticDataMember: SymbolInformation._Kind.ValueType  # 77
        """Analogous to 'StaticField', for C++"""
        StaticEvent: SymbolInformation._Kind.ValueType  # 78
        """For C#"""
        StaticField: SymbolInformation._Kind.ValueType  # 79
        """For C#"""
        StaticMethod: SymbolInformation._Kind.ValueType  # 80
        """For Java, C#, C++ etc."""
        StaticProperty: SymbolInformation._Kind.ValueType  # 81
        """For C#, TypeScript etc."""
        StaticVariable: SymbolInformation._Kind.ValueType  # 82
        """For C, C++"""
        String: SymbolInformation._Kind.ValueType  # 48
        Struct: SymbolInformation._Kind.ValueType  # 49
        Subscript: SymbolInformation._Kind.ValueType  # 47
        """For Swift"""
        Tactic: SymbolInformation._Kind.ValueType  # 50
        """For Lean"""
        Theorem: SymbolInformation._Kind.ValueType  # 51
        """For Lean"""
        ThisParameter: SymbolInformation._Kind.ValueType  # 52
        """Method receiver for languages
        'this' in JavaScript, C++, Java etc.
        """
        Trait: SymbolInformation._Kind.ValueType  # 53
        """Analogous to 'Protocol' and 'TypeClass', for Rust, Scala etc."""
        TraitMethod: SymbolInformation._Kind.ValueType  # 70
        """Analogous to 'AbstractMethod', for Rust, Scala etc."""
        Type: SymbolInformation._Kind.ValueType  # 54
        """Data type definition for languages like OCaml which use `type`
        rather than separate keywords like `struct` and `enum`.
        """
        TypeAlias: SymbolInformation._Kind.ValueType  # 55
        TypeClass: SymbolInformation._Kind.ValueType  # 56
        """Analogous to 'Trait' and 'Protocol', for Haskell, Purescript etc."""
        TypeClassMethod: SymbolInformation._Kind.ValueType  # 71
        """Analogous to 'AbstractMethod', for Haskell, Purescript etc."""
        TypeFamily: SymbolInformation._Kind.ValueType  # 57
        """For Haskell"""
        TypeParameter: SymbolInformation._Kind.ValueType  # 58
        Union: SymbolInformation._Kind.ValueType  # 59
        """For C, C++, Capn Proto"""
        Variable: SymbolInformation._Kind.ValueType  # 61
        """Next = 87;
        Feel free to open a PR proposing new language-specific kinds.
        """

    class Kind(_Kind, metaclass=_KindEnumTypeWrapper):
        """(optional) Kind represents the fine-grained category of a symbol, suitable for presenting
        information about the symbol's meaning in the language.

        For example:
        - A Java method would have the kind `Method` while a Go function would
          have the kind `Function`, even if the symbols for these use the same
          syntax for the descriptor `SymbolDescriptor.Suffix.Method`.
        - A Go struct has the symbol kind `Struct` while a Java class has
          the symbol kind `Class` even if they both have the same descriptor:
          `SymbolDescriptor.Suffix.Type`.

        Since Kind is more fine-grained than Suffix:
        - If two symbols have the same Kind, they should share the same Suffix.
        - If two symbols have different Suffixes, they should have different Kinds.
        """

    UnspecifiedKind: SymbolInformation.Kind.ValueType  # 0
    AbstractMethod: SymbolInformation.Kind.ValueType  # 66
    """A method which may or may not have a body. For Java, Kotlin etc."""
    Accessor: SymbolInformation.Kind.ValueType  # 72
    """For Ruby's attr_accessor"""
    Array: SymbolInformation.Kind.ValueType  # 1
    Assertion: SymbolInformation.Kind.ValueType  # 2
    """For Alloy"""
    AssociatedType: SymbolInformation.Kind.ValueType  # 3
    Attribute: SymbolInformation.Kind.ValueType  # 4
    """For C++"""
    Axiom: SymbolInformation.Kind.ValueType  # 5
    """For Lean"""
    Boolean: SymbolInformation.Kind.ValueType  # 6
    Class: SymbolInformation.Kind.ValueType  # 7
    Concept: SymbolInformation.Kind.ValueType  # 86
    """For C++"""
    Constant: SymbolInformation.Kind.ValueType  # 8
    Constructor: SymbolInformation.Kind.ValueType  # 9
    Contract: SymbolInformation.Kind.ValueType  # 62
    """For Solidity"""
    DataFamily: SymbolInformation.Kind.ValueType  # 10
    """For Haskell"""
    Delegate: SymbolInformation.Kind.ValueType  # 73
    """For C# and F#"""
    Enum: SymbolInformation.Kind.ValueType  # 11
    EnumMember: SymbolInformation.Kind.ValueType  # 12
    Error: SymbolInformation.Kind.ValueType  # 63
    Event: SymbolInformation.Kind.ValueType  # 13
    Extension: SymbolInformation.Kind.ValueType  # 84
    """For Dart"""
    Fact: SymbolInformation.Kind.ValueType  # 14
    """For Alloy"""
    Field: SymbolInformation.Kind.ValueType  # 15
    File: SymbolInformation.Kind.ValueType  # 16
    Function: SymbolInformation.Kind.ValueType  # 17
    Getter: SymbolInformation.Kind.ValueType  # 18
    """For 'get' in Swift, 'attr_reader' in Ruby"""
    Grammar: SymbolInformation.Kind.ValueType  # 19
    """For Raku"""
    Instance: SymbolInformation.Kind.ValueType  # 20
    """For Purescript and Lean"""
    Interface: SymbolInformation.Kind.ValueType  # 21
    Key: SymbolInformation.Kind.ValueType  # 22
    Lang: SymbolInformation.Kind.ValueType  # 23
    """For Racket"""
    Lemma: SymbolInformation.Kind.ValueType  # 24
    """For Lean"""
    Library: SymbolInformation.Kind.ValueType  # 64
    """For solidity"""
    Macro: SymbolInformation.Kind.ValueType  # 25
    Method: SymbolInformation.Kind.ValueType  # 26
    MethodAlias: SymbolInformation.Kind.ValueType  # 74
    """For Ruby"""
    MethodReceiver: SymbolInformation.Kind.ValueType  # 27
    """Analogous to 'ThisParameter' and 'SelfParameter', but for languages
    like Go where the receiver doesn't have a conventional name.
    """
    MethodSpecification: SymbolInformation.Kind.ValueType  # 67
    """Analogous to 'AbstractMethod', for Go."""
    Message: SymbolInformation.Kind.ValueType  # 28
    """For Protobuf"""
    Mixin: SymbolInformation.Kind.ValueType  # 85
    """For Dart"""
    Modifier: SymbolInformation.Kind.ValueType  # 65
    """For Solidity"""
    Module: SymbolInformation.Kind.ValueType  # 29
    Namespace: SymbolInformation.Kind.ValueType  # 30
    Null: SymbolInformation.Kind.ValueType  # 31
    Number: SymbolInformation.Kind.ValueType  # 32
    Object: SymbolInformation.Kind.ValueType  # 33
    Operator: SymbolInformation.Kind.ValueType  # 34
    Package: SymbolInformation.Kind.ValueType  # 35
    PackageObject: SymbolInformation.Kind.ValueType  # 36
    Parameter: SymbolInformation.Kind.ValueType  # 37
    ParameterLabel: SymbolInformation.Kind.ValueType  # 38
    Pattern: SymbolInformation.Kind.ValueType  # 39
    """For Haskell's PatternSynonyms"""
    Predicate: SymbolInformation.Kind.ValueType  # 40
    """For Alloy"""
    Property: SymbolInformation.Kind.ValueType  # 41
    Protocol: SymbolInformation.Kind.ValueType  # 42
    """Analogous to 'Trait' and 'TypeClass', for Swift and Objective-C"""
    ProtocolMethod: SymbolInformation.Kind.ValueType  # 68
    """Analogous to 'AbstractMethod', for Swift and Objective-C."""
    PureVirtualMethod: SymbolInformation.Kind.ValueType  # 69
    """Analogous to 'AbstractMethod', for C++."""
    Quasiquoter: SymbolInformation.Kind.ValueType  # 43
    """For Haskell"""
    SelfParameter: SymbolInformation.Kind.ValueType  # 44
    """'self' in Python, Rust, Swift etc."""
    Setter: SymbolInformation.Kind.ValueType  # 45
    """For 'set' in Swift, 'attr_writer' in Ruby"""
    Signature: SymbolInformation.Kind.ValueType  # 46
    """For Alloy, analogous to 'Struct'."""
    SingletonClass: SymbolInformation.Kind.ValueType  # 75
    """For Ruby"""
    SingletonMethod: SymbolInformation.Kind.ValueType  # 76
    """Analogous to 'StaticMethod', for Ruby."""
    StaticDataMember: SymbolInformation.Kind.ValueType  # 77
    """Analogous to 'StaticField', for C++"""
    StaticEvent: SymbolInformation.Kind.ValueType  # 78
    """For C#"""
    StaticField: SymbolInformation.Kind.ValueType  # 79
    """For C#"""
    StaticMethod: SymbolInformation.Kind.ValueType  # 80
    """For Java, C#, C++ etc."""
    StaticProperty: SymbolInformation.Kind.ValueType  # 81
    """For C#, TypeScript etc."""
    StaticVariable: SymbolInformation.Kind.ValueType  # 82
    """For C, C++"""
    String: SymbolInformation.Kind.ValueType  # 48
    Struct: SymbolInformation.Kind.ValueType  # 49
    Subscript: SymbolInformation.Kind.ValueType  # 47
    """For Swift"""
    Tactic: SymbolInformation.Kind.ValueType  # 50
    """For Lean"""
    Theorem: SymbolInformation.Kind.ValueType  # 51
    """For Lean"""
    ThisParameter: SymbolInformation.Kind.ValueType  # 52
    """Method receiver for languages
    'this' in JavaScript, C++, Java etc.
    """
    Trait: SymbolInformation.Kind.ValueType  # 53
    """Analogous to 'Protocol' and 'TypeClass', for Rust, Scala etc."""
    TraitMethod: SymbolInformation.Kind.ValueType  # 70
    """Analogous to 'AbstractMethod', for Rust, Scala etc."""
    Type: SymbolInformation.Kind.ValueType  # 54
    """Data type definition for languages like OCaml which use `type`
    rather than separate keywords like `struct` and `enum`.
    """
    TypeAlias: SymbolInformation.Kind.ValueType  # 55
    TypeClass: SymbolInformation.Kind.ValueType  # 56
    """Analogous to 'Trait' and 'Protocol', for Haskell, Purescript etc."""
    TypeClassMethod: SymbolInformation.Kind.ValueType  # 71
    """Analogous to 'AbstractMethod', for Haskell, Purescript etc."""
    TypeFamily: SymbolInformation.Kind.ValueType  # 57
    """For Haskell"""
    TypeParameter: SymbolInformation.Kind.ValueType  # 58
    Union: SymbolInformation.Kind.ValueType  # 59
    """For C, C++, Capn Proto"""
    Value: SymbolInformation.Kind.ValueType  # 60
    Variable: SymbolInformation.Kind.ValueType  # 61
    """Next = 87;
    Feel free to open a PR proposing new language-specific kinds.
    """

    SYMBOL_FIELD_NUMBER: _builtins.int
    DOCUMENTATION_FIELD_NUMBER: _builtins.int
    RELATIONSHIPS_FIELD_NUMBER: _builtins.int
    KIND_FIELD_NUMBER: _builtins.int
    DISPLAY_NAME_FIELD_NUMBER: _builtins.int
    SIGNATURE_DOCUMENTATION_FIELD_NUMBER: _builtins.int
    ENCLOSING_SYMBOL_FIELD_NUMBER: _builtins.int
    symbol: _builtins.str
    """Identifier of this symbol, which can be referenced from `Occurence.symbol`.
    The string must be formatted according to the grammar in `Symbol`.
    """
    kind: Global___SymbolInformation.Kind.ValueType
    """The kind of this symbol. Use this field instead of
    `SymbolDescriptor.Suffix` to determine whether something is, for example, a
    class or a method.
    """
    display_name: _builtins.str
    """(optional) The name of this symbol as it should be displayed to the user.
    For example, the symbol "com/example/MyClass#myMethod(+1)." should have the
    display name "myMethod". The `symbol` field is not a reliable source of
    the display name for several reasons:

    - Local symbols don't encode the name.
    - Some languages have case-insensitive names, so the symbol is all-lowercase.
    - The symbol may encode names with special characters that should not be
      displayed to the user.
    """
    enclosing_symbol: _builtins.str
    """(optional) The enclosing symbol if this is a local symbol.  For non-local
    symbols, the enclosing symbol should be parsed from the `symbol` field
    using the `Descriptor` grammar.

    The primary use-case for this field is to allow local symbol to be displayed
    in a symbol hierarchy for API documentation. It's OK to leave this field
    empty for local variables since local variables usually don't belong in API
    documentation. However, in the situation that you wish to include a local
    symbol in the hierarchy, then you can use `enclosing_symbol` to locate the
    "parent" or "owner" of this local symbol. For example, a Java indexer may
    choose to use local symbols for private class fields while providing an
    `enclosing_symbol` to reference the enclosing class to allow the field to
    be part of the class documentation hierarchy. From the perspective of an
    author of an indexer, the decision to use a local symbol or global symbol
    should exclusively be determined whether the local symbol is accessible
    outside the document, not by the capability to find the enclosing
    symbol.
    """
    @_builtins.property
    def documentation(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
        """(optional, but strongly recommended) The markdown-formatted documentation
        for this symbol. Use `SymbolInformation.signature_documentation` to
        document the method/class/type signature of this symbol.
        Due to historical reasons, indexers may include signature documentation in
        this field by rendering markdown code blocks. New indexers should only
        include non-code documentation in this field, for example docstrings.
        """

    @_builtins.property
    def relationships(self) -> _containers.RepeatedCompositeFieldContainer[Global___Relationship]:
        """(optional) Relationships to other symbols (e.g., implements, type definition)."""

    @_builtins.property
    def signature_documentation(self) -> Global___Document:
        """(optional) The signature of this symbol as it's displayed in API
        documentation or in hover tooltips. For example, a Java method that adds
        two numbers this would have `Document.language = "java"` and `Document.text
        = "void add(int a, int b)". The `language` and `text` fields are required
        while other fields such as `Documentation.occurrences` can be optionally
        included to support hyperlinking referenced symbols in the signature.
        """

    def __init__(
        self,
        *,
        symbol: _builtins.str = ...,
        documentation: _abc.Iterable[_builtins.str] | None = ...,
        relationships: _abc.Iterable[Global___Relationship] | None = ...,
        kind: Global___SymbolInformation.Kind.ValueType = ...,
        display_name: _builtins.str = ...,
        signature_documentation: Global___Document | None = ...,
        enclosing_symbol: _builtins.str = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["signature_documentation", b"signature_documentation"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["display_name", b"display_name", "documentation", b"documentation", "enclosing_symbol", b"enclosing_symbol", "kind", b"kind", "relationships", b"relationships", "signature_documentation", b"signature_documentation", "symbol", b"symbol"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___SymbolInformation: _TypeAlias = SymbolInformation  # noqa: Y015

@_typing.final
class Relationship(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    SYMBOL_FIELD_NUMBER: _builtins.int
    IS_REFERENCE_FIELD_NUMBER: _builtins.int
    IS_IMPLEMENTATION_FIELD_NUMBER: _builtins.int
    IS_TYPE_DEFINITION_FIELD_NUMBER: _builtins.int
    IS_DEFINITION_FIELD_NUMBER: _builtins.int
    symbol: _builtins.str
    is_reference: _builtins.bool
    """When resolving "Find references", this field documents what other symbols
    should be included together with this symbol. For example, consider the
    following TypeScript code that defines two symbols `Animal#sound()` and
    `Dog#sound()`:
    ```ts
    interface Animal {
              ^^^^^^ definition Animal#
      sound(): string
      ^^^^^ definition Animal#sound()
    }
    class Dog implements Animal {
          ^^^ definition Dog#, relationships = [{symbol: "Animal#", is_implementation: true}]
      public sound(): string { return "woof" }
             ^^^^^ definition Dog#sound(), references_symbols = Animal#sound(), relationships = [{symbol: "Animal#sound()", is_implementation:true, is_reference: true}]
    }
    const animal: Animal = new Dog()
                  ^^^^^^ reference Animal#
    console.log(animal.sound())
                       ^^^^^ reference Animal#sound()
    ```
    Doing "Find references" on the symbol `Animal#sound()` should return
    references to the `Dog#sound()` method as well. Vice-versa, doing "Find
    references" on the `Dog#sound()` method should include references to the
    `Animal#sound()` method as well.
    """
    is_implementation: _builtins.bool
    """Similar to `is_reference` but for "Find implementations".
    It's common for `is_implementation` and `is_reference` to both be true but
    it's not always the case.
    In the TypeScript example above, observe that `Dog#` has an
    `is_implementation` relationship with `"Animal#"` but not `is_reference`.
    This is because "Find references" on the "Animal#" symbol should not return
    "Dog#". We only want "Dog#" to return as a result for "Find
    implementations" on the "Animal#" symbol.
    """
    is_type_definition: _builtins.bool
    """Similar to `references_symbols` but for "Go to type definition"."""
    is_definition: _builtins.bool
    """Allows overriding the behavior of "Go to definition" and "Find references"
    for symbols which do not have a definition of their own or could
    potentially have multiple definitions.

    For example, in a language with single inheritance and no field overriding,
    inherited fields can reuse the same symbol as the ancestor which declares
    the field. In such a situation, is_definition is not needed.

    On the other hand, in languages with single inheritance and some form
    of mixins, you can use is_definition to relate the symbol to the
    matching symbol in ancestor classes, and is_reference to relate the
    symbol to the matching symbol in mixins.

    NOTE: At the moment, due to limitations of the SCIP to LSIF conversion,
    only global symbols in an index are allowed to use is_definition.
    The relationship may not get recorded if either symbol is local.
    Update registerInverseRelationships on adding a new field here.
    """
    def __init__(
        self,
        *,
        symbol: _builtins.str = ...,
        is_reference: _builtins.bool = ...,
        is_implementation: _builtins.bool = ...,
        is_type_definition: _builtins.bool = ...,
        is_definition: _builtins.bool = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["is_definition", b"is_definition", "is_implementation", b"is_implementation", "is_reference", b"is_reference", "is_type_definition", b"is_type_definition", "symbol", b"symbol"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Relationship: _TypeAlias = Relationship  # noqa: Y015

@_typing.final
class Occurrence(_message.Message):
    """Occurrence associates a source position with a symbol and/or highlighting
    information.

    If possible, indexers should try to bundle logically related information
    across occurrences into a single occurrence to reduce payload sizes.
    """

    DESCRIPTOR: _descriptor.Descriptor

    RANGE_FIELD_NUMBER: _builtins.int
    SYMBOL_FIELD_NUMBER: _builtins.int
    SYMBOL_ROLES_FIELD_NUMBER: _builtins.int
    OVERRIDE_DOCUMENTATION_FIELD_NUMBER: _builtins.int
    SYNTAX_KIND_FIELD_NUMBER: _builtins.int
    DIAGNOSTICS_FIELD_NUMBER: _builtins.int
    ENCLOSING_RANGE_FIELD_NUMBER: _builtins.int
    symbol: _builtins.str
    """(optional) The symbol that appears at this position. See
    `SymbolInformation.symbol` for how to format symbols as strings.
    """
    symbol_roles: _builtins.int
    """(optional) Bitset containing `SymbolRole`s in this occurrence.
    See `SymbolRole`'s documentation for how to read and write this field.
    """
    syntax_kind: Global___SyntaxKind.ValueType
    """(optional) What syntax highlighting class should be used for this range?"""
    @_builtins.property
    def range(self) -> _containers.RepeatedScalarFieldContainer[_builtins.int]:
        """Half-open [start, end) range of this occurrence. Must be exactly three or four
        elements:

        - Four elements: `[startLine, startCharacter, endLine, endCharacter]`
        - Three elements: `[startLine, startCharacter, endCharacter]`. The end line
          is inferred to have the same value as the start line.

        It is allowed for the range to be empty (i.e. start==end).

        Line numbers and characters are always 0-based. Make sure to increment the
        line/character values before displaying them in an editor-like UI because
        editors conventionally use 1-based numbers.

        The 'character' value is interpreted based on the PositionEncoding for
        the Document.

        Historical note: the original draft of this schema had a `Range` message
        type with `start` and `end` fields of type `Position`, mirroring LSP.
        Benchmarks revealed that this encoding was inefficient and that we could
        reduce the total payload size of an index by 50% by using `repeated int32`
        instead. The `repeated int32` encoding is admittedly more embarrassing to
        work with in some programming languages but we hope the performance
        improvements make up for it.
        """

    @_builtins.property
    def override_documentation(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
        """(optional) CommonMark-formatted documentation for this specific range. If
        empty, the `Symbol.documentation` field is used instead. One example
        where this field might be useful is when the symbol represents a generic
        function (with abstract type parameters such as `List<T>`) and at this
        occurrence we know the exact values (such as `List<String>`).

        This field can also be used for dynamically or gradually typed languages,
        which commonly allow for type-changing assignment.
        """

    @_builtins.property
    def diagnostics(self) -> _containers.RepeatedCompositeFieldContainer[Global___Diagnostic]:
        """(optional) Diagnostics that have been reported for this specific range."""

    @_builtins.property
    def enclosing_range(self) -> _containers.RepeatedScalarFieldContainer[_builtins.int]:
        """(optional) Using the same encoding as the sibling `range` field, half-open
        source range of the nearest non-trivial enclosing AST node. This range must
        enclose the `range` field. Example applications that make use of the
        enclosing_range field:

        - Call hierarchies: to determine what symbols are references from the body
          of a function
        - Symbol outline: to display breadcrumbs from the cursor position to the
          root of the file
        - Expand selection: to select the nearest enclosing AST node.
        - Highlight range: to indicate the AST expression that is associated with a
          hover popover

        For definition occurrences, the enclosing range should indicate the
        start/end bounds of the entire definition AST node, including
        documentation.
        ```
        const n = 3
              ^ range
        ^^^^^^^^^^^ enclosing_range

        /** Parses the string into something */
        ^ enclosing_range start --------------------------------------|
        function parse(input string): string {                        |
                 ^^^^^ range                                          |
            return input.slice(n)                                     |
        }                                                             |
        ^ enclosing_range end <---------------------------------------|
        ```

        Any attributes/decorators/attached macros should also be part of the
        enclosing range.

        ```python
        @cache
        ^ enclosing_range start---------------------|
        def factorial(n):                           |
            return n * factorial(n-1) if n else 1   |
        < enclosing_range end-----------------------|

        ```

        For reference occurrences, the enclosing range should indicate the start/end
        bounds of the parent expression.
        ```
        const a = a.b
                    ^ range
                  ^^^ enclosing_range
        const b = a.b(41).f(42).g(43)
                          ^ range
                  ^^^^^^^^^^^^^ enclosing_range
        ```
        """

    def __init__(
        self,
        *,
        range: _abc.Iterable[_builtins.int] | None = ...,
        symbol: _builtins.str = ...,
        symbol_roles: _builtins.int = ...,
        override_documentation: _abc.Iterable[_builtins.str] | None = ...,
        syntax_kind: Global___SyntaxKind.ValueType = ...,
        diagnostics: _abc.Iterable[Global___Diagnostic] | None = ...,
        enclosing_range: _abc.Iterable[_builtins.int] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["diagnostics", b"diagnostics", "enclosing_range", b"enclosing_range", "override_documentation", b"override_documentation", "range", b"range", "symbol", b"symbol", "symbol_roles", b"symbol_roles", "syntax_kind", b"syntax_kind"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Occurrence: _TypeAlias = Occurrence  # noqa: Y015

@_typing.final
class Diagnostic(_message.Message):
    """Represents a diagnostic, such as a compiler error or warning, which should be
    reported for a document.
    """

    DESCRIPTOR: _descriptor.Descriptor

    SEVERITY_FIELD_NUMBER: _builtins.int
    CODE_FIELD_NUMBER: _builtins.int
    MESSAGE_FIELD_NUMBER: _builtins.int
    SOURCE_FIELD_NUMBER: _builtins.int
    TAGS_FIELD_NUMBER: _builtins.int
    severity: Global___Severity.ValueType
    """Should this diagnostic be reported as an error, warning, info, or hint?"""
    code: _builtins.str
    """(optional) Code of this diagnostic, which might appear in the user interface."""
    message: _builtins.str
    """Message of this diagnostic."""
    source: _builtins.str
    """(optional) Human-readable string describing the source of this diagnostic, e.g.
    'typescript' or 'super lint'.
    """
    @_builtins.property
    def tags(self) -> _containers.RepeatedScalarFieldContainer[Global___DiagnosticTag.ValueType]: ...
    def __init__(
        self,
        *,
        severity: Global___Severity.ValueType = ...,
        code: _builtins.str = ...,
        message: _builtins.str = ...,
        source: _builtins.str = ...,
        tags: _abc.Iterable[Global___DiagnosticTag.ValueType] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["code", b"code", "message", b"message", "severity", b"severity", "source", b"source", "tags", b"tags"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Diagnostic: _TypeAlias = Diagnostic  # noqa: Y015
